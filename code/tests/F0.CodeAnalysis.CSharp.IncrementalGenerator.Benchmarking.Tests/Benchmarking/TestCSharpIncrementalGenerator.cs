using System.Collections.Immutable;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace F0.CodeAnalysis.CSharp.Tests.Benchmarking;

[Generator(LanguageNames.CSharp)]
internal sealed class TestCSharpIncrementalGenerator : IIncrementalGenerator
{
	private const string defaultFileExtension = ".g.cs";

	private static readonly DiagnosticDescriptor Rule = new(
		"ID0001",
		"Test-Title",
		"Test-Message: {0}",
		"Test-Category",
		DiagnosticSeverity.Warning,
		true,
		"Test-Description",
		"Test-HelpLinkUri",
		"Test-Tag"
	);

	internal int Initializations { get; private set; }
	internal int Executions { get; private set; }

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		Initializations++;

		IncrementalValuesProvider<SyntaxNode> syntaxProvider = context.SyntaxProvider
			.CreateSyntaxProvider(SyntaxProviderPredicate, SyntaxProviderTransform);

		IncrementalValueProvider<(ImmutableArray<SyntaxNode> Nodes, Compilation Compilation)> withCompilation =
			syntaxProvider.Collect().Combine(context.CompilationProvider);

		IncrementalValueProvider<((ImmutableArray<SyntaxNode> Nodes, Compilation Compilation) Other, ParseOptions ParseOptions)> withParseOptions =
			withCompilation.Combine(context.ParseOptionsProvider);

		IncrementalValueProvider<(((ImmutableArray<SyntaxNode> Nodes, Compilation Compilation) Other, ParseOptions ParseOptions) Other, ImmutableArray<AdditionalText> AdditionalTexts)> withAdditionalTexts =
			withParseOptions.Combine(context.AdditionalTextsProvider.Collect());

		IncrementalValueProvider<((((ImmutableArray<SyntaxNode> Nodes, Compilation Compilation) Other, ParseOptions ParseOptions) Other, ImmutableArray<AdditionalText> AdditionalTexts) Other, AnalyzerConfigOptionsProvider AnalyzerConfigOptionsProvider)> withAnalyzerConfigOptionsProvider =
			withAdditionalTexts.Combine(context.AnalyzerConfigOptionsProvider);

		IncrementalValueProvider<(((((ImmutableArray<SyntaxNode> Nodes, Compilation Compilation) Other, ParseOptions ParseOptions) Other, ImmutableArray<AdditionalText> AdditionalTexts) Other, AnalyzerConfigOptionsProvider AnalyzerConfigOptionsProvider) Other, ImmutableArray<MetadataReference> MetadataReferences)> withMetadataReferences =
			withAnalyzerConfigOptionsProvider.Combine(context.MetadataReferencesProvider.Collect());

		context.RegisterSourceOutput(withMetadataReferences, Execute);
	}

	private static bool SyntaxProviderPredicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
		=> syntaxNode is ClassDeclarationSyntax;

	private static SyntaxNode SyntaxProviderTransform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
		=> context.Node;

	private void Execute(SourceProductionContext context, (((((ImmutableArray<SyntaxNode> Nodes, Compilation Compilation) Other, ParseOptions ParseOptions) Other, ImmutableArray<AdditionalText> AdditionalTexts) Other, AnalyzerConfigOptionsProvider AnalyzerConfigOptionsProvider) Other, ImmutableArray<MetadataReference> MetadataReferences) source)
	{
		Executions++;

		Debug.Assert(source.Other.Other.Other.Other.Compilation is CSharpCompilation);
		var compilation = Unsafe.As<CSharpCompilation>(source.Other.Other.Other.Other.Compilation);

		Debug.Assert(source.Other.Other.Other.ParseOptions is CSharpParseOptions);
		var parseOptions = Unsafe.As<CSharpParseOptions>(source.Other.Other.Other.ParseOptions);

		string hintName = $"{GetType()}{defaultFileExtension}";
		StringBuilder sourceText = new();

		sourceText.AppendLine("// <auto-generated/>");
		if (parseOptions.LanguageVersion >= LanguageVersion.CSharp8)
		{
			sourceText.AppendLine("#nullable enable");
		}
		sourceText.AppendLine();
		sourceText.AppendLine("/*");

		sourceText.AppendLine($"# {nameof(source.Other.Other.Other.Other.Nodes)}: {source.Other.Other.Other.Other.Nodes.Length}");

		sourceText.AppendLine($"{nameof(compilation.Language)}: {compilation.Language}");
		sourceText.AppendLine($"{nameof(compilation.Options.AllowUnsafe)}: {compilation.Options.AllowUnsafe}");

		sourceText.AppendLine($"{nameof(parseOptions.LanguageVersion)}: {parseOptions.LanguageVersion}");

		const string key = "Analyzer_Config_Key";
		_ = source.Other.AnalyzerConfigOptionsProvider.GlobalOptions.TryGetValue(key, out string? value)
			? sourceText.AppendLine($"Analyzer Config Value of '{key}': {value}")
			: sourceText.AppendLine($"Analyzer Config Value of '{key}' not found.");

		sourceText.AppendLine($"# {WellKnownGeneratorInputs.MetadataReferences}: {source.MetadataReferences.Length}");
		sourceText.AppendLine($"Last {nameof(MetadataReference)}: {Path.GetFileName(source.MetadataReferences.Last().Display)}");

		sourceText.AppendLine("*/");

		context.AddSource(hintName, sourceText.ToString());

		foreach (AdditionalText additionalText in source.Other.Other.AdditionalTexts)
		{
			sourceText.Clear();
			sourceText.AppendLine("/*");
			sourceText.AppendLine(additionalText.GetText(CancellationToken.None)?.ToString());
			sourceText.AppendLine("*/");

			hintName = $"{Path.GetFileNameWithoutExtension(additionalText.Path)}{defaultFileExtension}";
			context.AddSource(hintName, sourceText.ToString());
		}

		ImmutableDictionary<string, string?> properties = CreateProperties();

		foreach (SyntaxNode node in source.Other.Other.Other.Other.Nodes)
		{
			if (node is ClassDeclarationSyntax @class)
			{
				Location location = @class.Identifier.GetLocation();
				var diagnostic = Diagnostic.Create(Rule, location, DiagnosticSeverity.Error, new[] { location }, properties, @class.Identifier.ValueText);
				context.ReportDiagnostic(diagnostic);
			}
		}
	}

	private static ImmutableDictionary<string, string?> CreateProperties()
	{
		ImmutableDictionary<string, string?>.Builder builder = ImmutableDictionary.CreateBuilder<string, string?>();
		builder.Add("Zero", "One");
		builder.Add("Two", "Three");
		builder.Add("Four", "Five");
		builder.Add("Six", "Seven");
		builder.Add("Eight", "Nine");
		return builder.ToImmutable();
	}
}
